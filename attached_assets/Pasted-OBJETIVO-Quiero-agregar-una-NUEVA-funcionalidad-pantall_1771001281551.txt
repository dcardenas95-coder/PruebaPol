OBJETIVO
Quiero agregar una NUEVA funcionalidad (pantalla + lógica) para ejecutar una estrategia específica en mercados de Polymarket. NO debes modificar ni refactorizar el funcionamiento existente del bot. No cambies endpoints actuales, ni estructura base, ni flujos que ya estén en producción. Solo agrega código nuevo, integrado de forma mínima y segura.

RESTRICCIONES CRÍTICAS
1) NO modificar archivos existentes salvo para: (a) agregar una ruta nueva, (b) registrar un componente nuevo en el router/menu, (c) registrar un handler nuevo en el backend. Todo cambio debe ser mínimo y local.
2) NO romper el bot actual. Si hay conflictos, crea un módulo aislado.
3) NO hardcodear llaves. Usa env vars existentes.
4) TODO debe operar con órdenes LÍMITE únicamente. Prohibido market orders.
5) Debe incluir logs claros, control de estado y failsafes.

NUEVA PANTALLA
Crear una pantalla nueva llamada: “Strategies → 5m Dual-Entry (45c/45c)”
- Debe permitir configurar y activar/desactivar esta estrategia.
- Debe permitir seleccionar el mercado (marketId) y resolver token IDs YES/NO.
- Debe mostrar estado en tiempo real: ciclo actual, tiempos (T-180s, T-30s, startTime, T+10s), órdenes colocadas, fills, inventario, órdenes activas.
- Debe mostrar un log (timeline) del último ciclo y de los últimos N ciclos.

ESTRATEGIA A IMPLEMENTAR (exacta)
Contexto: Mercados de “ventana de 5 minutos”. Para cada ventana, el bot debe colocar órdenes ANTES del inicio.

Parámetros default (editables desde UI):
- entryPrice = 0.45
- tpPrice = 0.65
- scratchPrice = 0.45
- entryLeadSecondsPrimary = 180   (3 minutos antes del inicio)
- entryLeadSecondsRefresh = 30    (30 segundos antes del inicio)
- postStartCleanupSeconds = 10    (10 segundos después del inicio)
- orderSize (tamaño por pierna) = configurable
- maxConcurrentCycles = 1
- onlyLimitOrders = true

Lógica por cada ciclo (cada ventana de 5 min):
1) En T - 180s:
   - Colocar 2 órdenes límite:
     - BUY YES @ 0.45 (size = orderSize)
     - BUY NO  @ 0.45 (size = orderSize)
2) En T - 30s:
   - “Refresh”: si alguna no está llena, cancelar la(s) no llenada(s) y repostear @ 0.45 para quedar vigente.
3) Monitorear fills (por user events / order status):
   - Si se llenan ambas piernas (YES y NO) antes o poco después del inicio:
     a) Elegir el “lado ganador” para TP:
        - Determinarlo comparando el mid (o best bid/ask) de YES vs NO justo al momento de quedar hedgeado:
          - winner = lado con mid mayor (o best bid mayor).
     b) Colocar 2 órdenes límite de salida:
        - SELL winner @ 0.65 por la cantidad llena de ese lado
        - SELL loser  @ 0.45 por la cantidad llena de ese lado (scratch)
4) Cleanup post-inicio (T + 10s):
   - Si no se llenó ninguna pierna: cancelar todo y terminar ciclo (FLAT).
   - Si solo se llenó una pierna (PARTIAL_FILL):
     - Cancelar la pierna faltante (unfilled)
     - Poner una orden límite de salida para la pierna llena para quedar flat:
       - SELL filledLeg @ 0.45 por el size realmente lleno (si existe best_bid >= 0.45, usar best_bid; si no, usar 0.45).
5) Exit TTL (configurable, default 120s):
   - Si el TP @ 0.65 no se llena en TTL, NO bajar precio automáticamente (por ahora). Mantenerlo o dejarlo como orden activa. Registrar en logs.

REQUISITOS DE ARQUITECTURA (NUEVO MÓDULO)
Agregar un módulo aislado:
- /src/strategies/dualEntry5m/
  - dualEntry5m.types.ts
  - dualEntry5m.engine.ts          (state machine)
  - dualEntry5m.scheduler.ts       (cálculo de tiempos y disparadores)
  - dualEntry5m.orderManager.ts    (wrapper: createOrder/postOrder/cancel + retries + idempotencia)
  - dualEntry5m.marketData.ts      (best bid/ask, mid; usando el canal actual que ya tenga el bot o WS nuevo SOLO si hace falta)
  - dualEntry5m.persistence.ts     (guardar config + últimos ciclos + logs; preferible DB ya existente, si no, JSON file local)

State machine obligatoria (para evitar bugs):
IDLE → ARMED → ENTRY_WORKING → PARTIAL_FILL → HEDGED → EXIT_WORKING → DONE
y estado FAILSAFE/CLEANUP.

Idempotencia:
- Cada acción (post/cancel) debe tener “dedupe keys” por ciclo para evitar duplicados en reintentos.
- Si reinicia el proceso, la estrategia debe poder reconstruir su estado leyendo órdenes abiertas y continuar o limpiar.

INTEGRACIÓN MÍNIMA
- Agregar un endpoint nuevo para:
  - GET /api/strategies/dual-entry-5m/config
  - POST /api/strategies/dual-entry-5m/config (guardar config)
  - POST /api/strategies/dual-entry-5m/start
  - POST /api/strategies/dual-entry-5m/stop
  - GET /api/strategies/dual-entry-5m/status (estado + órdenes + fills + log)
- Agregar una ruta de UI nueva en el menú “Strategies”.

NO TOCAR
- No cambiar cómo funciona el bot actual.
- No cambiar modelos/DB existentes a menos que sea estrictamente necesario; si necesitas persistencia, crea una tabla/colección nueva, aislada.

SALIDA ESPERADA
1) Pantalla nueva funcionando con controles (start/stop) + configuración editable.
2) Engine implementado con la lógica arriba.
3) Logs visibles en UI (últimos ciclos).
4) Prueba mínima: modo “dry-run” (sin postOrder) opcional desde UI para validar scheduler y estados sin riesgo.

ANTES DE CODIFICAR
Haz un inventario rápido (2-5 bullets) de dónde se integrará en el repo (router, server, db). Luego implementa siguiendo estas instrucciones.

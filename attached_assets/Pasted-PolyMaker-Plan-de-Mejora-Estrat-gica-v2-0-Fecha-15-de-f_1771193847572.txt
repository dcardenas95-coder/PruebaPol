PolyMaker â€” Plan de Mejora EstratÃ©gica v2.0
Fecha: 15 de febrero de 2026
Basado en: AuditorÃ­a tÃ©cnica STRATEGY_TECHNICAL_AUDIT.md + AnÃ¡lisis P&L sesiÃ³n paper 2026-02-15
Autor: ConsultorÃ­a de Estrategia AlgorÃ­tmica

DiagnÃ³stico: Â¿Por QuÃ© PerdiÃ³ -$27.74 (-37.82%)?
Antes de proponer mejoras, es fundamental entender quÃ© fallÃ³. Cruzando el P&L real con la arquitectura del cÃ³digo, identifico 5 causas raÃ­z:
Causa 1: El bot no tiene "edge" â€” opera sin ventaja informacional
Los bots exitosos en Polymarket BTC 5m/15m (como "gabagool22" que genera $1,700+/dÃ­a solo en maker rebates) explotan latencia de precios: monitorean Binance WebSocket en tiempo real y detectan cuando el precio spot de BTC ya se moviÃ³ pero Polymarket aÃºn no lo refleja. Tu bot en cambio usa getBestSide() que simplemente mira la profundidad del orderbook â€” esto no es un edge, es reaccionar a informaciÃ³n que todos ya ven.
Causa 2: La estrategia Legacy FSM compra caro por diseÃ±o
La lÃ³gica de entrada en MAKING (lÃ­nea 780-802) compra al bestBid, que es el precio mÃ¡s alto del lado comprador. En un mercado 50/50, esto significa comprar entre $0.45-$0.55. Pero el TP requiere que el precio suba $0.03-$0.05 adicionales. En un mercado de 5 minutos con BTC moviÃ©ndose ~0.1-0.3%, la probabilidad de que el precio suba 3-5 centavos despuÃ©s de tu compra es baja.
Causa 3: Sin stop-loss en la estrategia Legacy FSM
El Risk Manager tiene maxDailyLoss y maxConsecutiveLosses, pero no hay stop-loss por trade individual. El Trade 7 perdiÃ³ 78% de su valor ($12.80 â†’ $2.80) sin que ningÃºn mecanismo lo detuviera. La FSM solo corta pÃ©rdidas al llegar a HEDGE_LOCK (45s antes del fin), pero para entonces el mercado ya castigÃ³ la posiciÃ³n.
Causa 4: La cascada de ventas amplifica pÃ©rdidas
Las ventas en cascada despuÃ©s del Trade 10 (20â†’10â†’5â†’2.5â†’1.25â†’...) son un patrÃ³n martingale inverso que divide la posiciÃ³n en piezas cada vez mÃ¡s pequeÃ±as a precios decrecientes. Esto genera mÃ¡s transacciones (mÃ¡s fees) y recupera menos capital que una sola venta agresiva al mejor precio disponible.
Causa 5: Escalamiento prematuro sin validaciÃ³n
El bot escalÃ³ de $1 a $20 por trade sin demostrar rentabilidad. El Ãºnico trade ganador ($0.04 de profit) se usÃ³ como seÃ±al para escalar 20x.

Estrategia Propuesta: Latency-Informed Market Making (LIMM)
La mejora fundamental es darle al bot un edge real basado en informaciÃ³n que el mercado aÃºn no ha procesado.
Principio Central

Monitorear el precio spot de BTC en Binance via WebSocket. Cuando detectas un movimiento confirmado (e.g., BTC sube $50 en 10 segundos), la probabilidad real de "Up" ya es ~70-85%, pero Polymarket aÃºn puede mostrar 50/50. Comprar el lado correcto antes de que el orderbook se ajuste.

Componente Nuevo: Binance Price Oracle
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              NUEVO: Binance Price Oracle                  â”‚
â”‚                                                           â”‚
â”‚  Binance WS (btcusdt@trade) â”€â”€â”€â”€â”€â–º Price Buffer (100ms)  â”‚
â”‚                                          â”‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚  â”‚                                                        â”‚
â”‚  â–¼                                                        â”‚
â”‚  Market Opening Price â—„â”€â”€ Capturar al inicio de ventana   â”‚
â”‚  Current Price â—„â”€â”€ ActualizaciÃ³n en tiempo real            â”‚
â”‚  Delta = Current - Opening                                â”‚
â”‚  Direction = UP si delta > threshold, DOWN si < -threshold â”‚
â”‚  Confidence = f(|delta|, time_elapsed, volatility)        â”‚
â”‚                                                           â”‚
â”‚  SeÃ±al de trading:                                        â”‚
â”‚  â”œâ”€â”€ STRONG_UP:  delta > $30 AND conf > 0.75              â”‚
â”‚  â”œâ”€â”€ WEAK_UP:    delta > $15 AND conf > 0.60              â”‚
â”‚  â”œâ”€â”€ NEUTRAL:    |delta| < $15                            â”‚
â”‚  â”œâ”€â”€ WEAK_DOWN:  delta < -$15 AND conf > 0.60             â”‚
â”‚  â””â”€â”€ STRONG_DOWN: delta < -$30 AND conf > 0.75            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ImplementaciÃ³n sugerida:
typescript// server/bot/binance-oracle.ts
interface PriceSignal {
  direction: 'UP' | 'DOWN' | 'NEUTRAL';
  strength: 'STRONG' | 'WEAK' | 'NONE';
  confidence: number;       // 0.0 - 1.0
  delta: number;            // Current - Opening price
  openingPrice: number;
  currentPrice: number;
  elapsedMs: number;        // Tiempo desde apertura del mercado
}

class BinanceOracle {
  private ws: WebSocket;
  private openingPrice: number = 0;
  private currentPrice: number = 0;
  private priceBuffer: number[] = [];
  
  // ParÃ¡metros configurables
  private STRONG_THRESHOLD = 30;   // USD
  private WEAK_THRESHOLD = 15;     // USD
  private MIN_CONFIDENCE = 0.60;
  
  getSignal(marketElapsedMs: number): PriceSignal {
    const delta = this.currentPrice - this.openingPrice;
    const absDelta = Math.abs(delta);
    
    // Confianza aumenta con: mayor delta, mÃ¡s tiempo transcurrido, 
    // consistencia de direcciÃ³n
    const timeFactor = Math.min(1, marketElapsedMs / 180000); // max a 3min
    const priceFactor = Math.min(1, absDelta / 50);
    const consistency = this.getDirectionConsistency(); // 0-1
    
    const confidence = (priceFactor * 0.5) + (timeFactor * 0.2) + (consistency * 0.3);
    
    let direction: 'UP' | 'DOWN' | 'NEUTRAL' = 'NEUTRAL';
    let strength: 'STRONG' | 'WEAK' | 'NONE' = 'NONE';
    
    if (absDelta >= this.STRONG_THRESHOLD && confidence >= 0.75) {
      direction = delta > 0 ? 'UP' : 'DOWN';
      strength = 'STRONG';
    } else if (absDelta >= this.WEAK_THRESHOLD && confidence >= this.MIN_CONFIDENCE) {
      direction = delta > 0 ? 'UP' : 'DOWN';
      strength = 'WEAK';
    }
    
    return { direction, strength, confidence, delta, 
             openingPrice: this.openingPrice, 
             currentPrice: this.currentPrice, 
             elapsedMs: marketElapsedMs };
  }
}

Mejoras por Componente
1. MAKING â€” Entrada Informada (Legacy FSM)
Problema actual: Compra al bestBid basado solo en profundidad del orderbook.
Mejora propuesta:
ANTES:
  getBestSide() â†’ bidDepth > askDepth Ã— 1.2 â†’ BUY
  
DESPUÃ‰S:
  1. Obtener seÃ±al de Binance Oracle
  2. SI signal.strength == 'STRONG':
     â†’ Comprar lado alineado con direcciÃ³n (UPâ†’YES, DOWNâ†’NO)
     â†’ Usar MAKER order (limit) al bestBid para ganar rebates
     â†’ Size = orderSize Ã— 1.5 (mayor convicciÃ³n)
  3. SI signal.strength == 'WEAK':
     â†’ Comprar lado alineado pero size = orderSize Ã— 0.75
  4. SI signal.direction == 'NEUTRAL':
     â†’ NO OPERAR (esperar seÃ±al clara)
     â†’ Esta es la mejora mÃ¡s importante: no forzar trades
Cambio clave: Reemplazar getBestSide() por getOracleAlignedSide():
typescript// Reemplazar en strategy-engine.ts
getOracleAlignedSide(signal: PriceSignal): { side: 'YES' | 'NO' | null, size: number } {
  if (signal.strength === 'NONE' || signal.direction === 'NEUTRAL') {
    return { side: null, size: 0 }; // NO OPERAR
  }
  
  const side = signal.direction === 'UP' ? 'YES' : 'NO';
  const sizeMultiplier = signal.strength === 'STRONG' ? 1.5 : 0.75;
  
  return { side, size: this.config.orderSize * sizeMultiplier };
}
2. STOP-LOSS Individual por Trade (NUEVO)
Componente inexistente que debe crearse.
typescript// Agregar a strategy-engine.ts o crear server/bot/stop-loss-manager.ts

interface StopLossConfig {
  maxLossPercent: number;      // Default: 15% del costo de entrada
  trailingEnabled: boolean;    // Trailing stop
  trailingPercent: number;     // Default: 10%
  timeDecayEnabled: boolean;   // Stop mÃ¡s agresivo conforme pasa el tiempo
}

class StopLossManager {
  checkStopLoss(position: Position, currentPrice: number, 
                remainingMs: number): boolean {
    const entryValue = position.size * position.avgEntryPrice;
    const currentValue = position.size * currentPrice;
    const lossPct = (entryValue - currentValue) / entryValue;
    
    // Stop fijo: 15% de pÃ©rdida
    if (lossPct >= this.config.maxLossPercent) {
      return true; // SALIR
    }
    
    // Time decay: conforme queda menos tiempo, el stop se ajusta
    if (this.config.timeDecayEnabled) {
      const timeProgress = 1 - (remainingMs / 300000); // 0â†’1 en 5min
      const adjustedStop = this.config.maxLossPercent * (1 - timeProgress * 0.5);
      // A mitad de mercado, stop = 10% en vez de 15%
      // A 1 min del final, stop = 7.5%
      if (lossPct >= adjustedStop) return true;
    }
    
    // Trailing stop: si el precio subiÃ³ y luego cayÃ³
    if (this.config.trailingEnabled && position.highWaterMark) {
      const dropFromHigh = (position.highWaterMark - currentPrice) / position.highWaterMark;
      if (dropFromHigh >= this.config.trailingPercent) return true;
    }
    
    return false;
  }
}
IntegraciÃ³n en el tick:
tick() {
  ...
  // NUEVO: Check stop-loss ANTES de cualquier otra lÃ³gica
  for (const position of openPositions) {
    if (stopLossManager.checkStopLoss(position, currentBid, remainingMs)) {
      await cancelAllTPOrders(position);
      await placeMarketSell(position, bestBid - 0.005); // Salida inmediata
      logEvent('STOP_LOSS_TRIGGERED', { position, loss: calculatedLoss });
    }
  }
  ...
}
3. Dual-Entry 5m â€” Mejoras al Pricing
Problema actual: entryPrice fijo o con dynamic entry basado solo en spread.
Mejora propuesta: Entry Price Oracle-Informed
ANTES (actual):
  Si spread > 0.20 â†’ entryPrice = dynamicEntryMin (conservador)
  Si spread < 0.05 â†’ entryPrice = dynamicEntryMax (agresivo)
  
DESPUÃ‰S (propuesto):
  1. Obtener seÃ±al de Binance Oracle
  2. Calcular el entry price del lado que PROBABLEMENTE ganarÃ¡:
     - Si Oracle dice STRONG_UP â†’ el YES probablemente ganarÃ¡
     - Para YES: usar entryPrice hasta dynamicEntryMax (mÃ¡s agresivo)
     - Para NO: usar entryPrice = dynamicEntryMin (conservador)
  3. Si Oracle dice NEUTRAL â†’ ambos lados a dynamicEntryMin
El TP dinÃ¡mico tambiÃ©n debe informarse del Oracle:
ANTES:
  momentum = getMomentum(windowMinutes) â†’ flat/strong â†’ tp ajustado
  
DESPUÃ‰S:
  oracleSignal + momentum del volatilityTracker combinados:
  - Oracle STRONG + momentum strong â†’ TP agresivo (momentumTpMax)
  - Oracle STRONG + momentum flat â†’ TP moderado
  - Oracle NEUTRAL â†’ TP conservador (momentumTpMin)
4. EliminaciÃ³n de la Cascada de Ventas
Problema: Las ventas en cascada (20â†’10â†’5â†’2.5â†’...) generan mÃ¡s fees y recuperan menos.
SoluciÃ³n: Una sola orden de salida al mejor precio disponible.
ANTES (actual):
  HEDGE_LOCK genera mÃºltiples Ã³rdenes escalonadas a precios decrecientes
  
DESPUÃ‰S:
  HEDGE_LOCK: UNA sola orden por posiciÃ³n
  â†’ Precio = bestBid - 0.01 (cruzar spread inmediatamente)
  â†’ Si no se llena en 5s â†’ re-price a bestBid - 0.02
  â†’ Si no se llena en 10s â†’ re-price a 0.01 (fire sale)
  â†’ MÃ¡ximo 3 re-prices, no fraccionar la posiciÃ³n
typescript// Reemplazar lÃ³gica de HEDGE_LOCK en strategy-engine.ts
async handleHedgeLock(position: Position, remainingMs: number): Promise<void> {
  // Cancelar TODAS las Ã³rdenes existentes primero
  await this.cancelAllOrders();
  
  // UNA sola orden de salida agresiva
  const urgency = remainingMs <= 20000 ? 'CRITICAL' : 
                  remainingMs <= 30000 ? 'HIGH' : 'MEDIUM';
  
  const priceOffset = urgency === 'CRITICAL' ? 0.02 : 
                      urgency === 'HIGH' ? 0.01 : 0.005;
  
  const exitPrice = Math.max(0.01, bestBid - priceOffset);
  
  await this.placeOrder({
    side: 'SELL',
    price: exitPrice,
    size: position.size, // TODA la posiciÃ³n, sin fraccionar
    tokenId: position.tokenId,
  });
  
  // Programar re-price si no se llena
  setTimeout(() => this.repriceIfNeeded(position, 0.02), 5000);
  setTimeout(() => this.repriceIfNeeded(position, 0.05), 10000);
}
5. Maker Orders y Rebates (Cambio Estructural)
Insight clave de la investigaciÃ³n: En Polymarket, los taker fees son ~1.5% a precio 50Â¢, pero los maker orders pagan 0% fees y GANAN rebates. El 100% de los taker fees se redistribuyen a makers diariamente.
Cambio fundamental: Todas las Ã³rdenes de entrada deben ser limit orders que se sientan en el orderbook (maker), no market orders que cruzan el spread (taker).
REGLA: NUNCA cruzar el spread para entrar
  - BUY YES: colocar limit order al bestBid (o bestBid + 0.005)
  - BUY NO: colocar limit order al bestBid (o bestBid + 0.005)
  - SELL (TP): colocar limit order al bestAsk (o bestAsk - 0.005)
  
EXCEPCIÃ“N: Solo cruzar spread para SALIDA DE EMERGENCIA (HEDGE_LOCK)
Impacto estimado:

Ahorro en fees: ~1.5% por trade Ã— $73 capital = ~$1.10 ahorrado
Maker rebates: variable pero puede ser $0.50-$2.00/dÃ­a con volumen suficiente

6. ProtecciÃ³n de Capital: Escalamiento Progresivo
Nueva regla de position sizing:
typescriptclass ProgressiveSizer {
  getOrderSize(stats: TradingStats): number {
    const { winRate, totalTrades, consecutiveWins, consecutiveLosses } = stats;
    
    // Nivel 1: ValidaciÃ³n (trades 1-20)
    if (totalTrades < 20) return 1; // $1 por trade
    
    // Nivel 2: ConfirmaciÃ³n (trades 21-50, requiere winRate > 55%)
    if (totalTrades < 50) {
      if (winRate < 0.55) return 1; // Mantener en $1
      return 5; // Escalar a $5
    }
    
    // Nivel 3: OperaciÃ³n (trades 51+, requiere winRate > 55%)
    if (winRate < 0.55) return 5; // Bajar a $5
    if (winRate >= 0.65) return 20; // Escalar a $20
    return 10; // TamaÃ±o estÃ¡ndar
    
    // ReducciÃ³n por pÃ©rdidas consecutivas
    if (consecutiveLosses >= 2) return Math.max(1, currentSize * 0.5);
    
    // Bonus por racha ganadora (mÃ¡x 1.5x)
    if (consecutiveWins >= 5) return Math.min(currentSize * 1.25, 20);
  }
}
7. Filtro de Condiciones de Mercado (Market Regime Filter)
Nuevo componente que evita operar en condiciones desfavorables:
typescriptinterface MarketRegime {
  regime: 'TRENDING' | 'RANGING' | 'VOLATILE' | 'DEAD';
  tradeable: boolean;
  reason?: string;
}

class MarketRegimeFilter {
  // Basado en datos de Binance Oracle + Polymarket orderbook
  getRegime(): MarketRegime {
    const vol = this.binanceOracle.getVolatility(5); // 5min
    const spread = this.marketData.spread;
    const depth = Math.min(this.marketData.bidDepth, this.marketData.askDepth);
    
    // DEAD: Sin liquidez
    if (depth < 50) return { regime: 'DEAD', tradeable: false, 
                             reason: 'Liquidez insuficiente' };
    
    // VOLATILE: Demasiada volatilidad (riesgo de slippage)
    if (vol > 0.5) return { regime: 'VOLATILE', tradeable: false, 
                            reason: `Vol ${vol}% > 0.5% threshold` };
    
    // TRENDING: Ideal para operar con el Oracle
    if (vol > 0.1 && vol <= 0.5) return { regime: 'TRENDING', tradeable: true };
    
    // RANGING: BTC plano, difÃ­cil ganar
    if (vol <= 0.1) return { regime: 'RANGING', tradeable: false, 
                             reason: 'Mercado sin movimiento' };
    
    return { regime: 'RANGING', tradeable: true };
  }
}

Resumen de Cambios por Archivo
ArchivoCambioPrioridadNUEVO server/bot/binance-oracle.tsBinance WebSocket price feed + seÃ±alesðŸ”´ CRÃTICANUEVO server/bot/stop-loss-manager.tsStop-loss individual por tradeðŸ”´ CRÃTICANUEVO server/bot/progressive-sizer.tsEscalamiento progresivo basado en performanceðŸ”´ CRÃTICANUEVO server/bot/market-regime-filter.tsFiltro de condiciones de mercadoðŸŸ¡ ALTAserver/bot/strategy-engine.tsReemplazar getBestSide() con Oracle, integrar stop-loss en tick, eliminar cascada en HEDGE_LOCKðŸ”´ CRÃTICAserver/bot/market-data.tsAgregar seÃ±al del Oracle al MarketData interfaceðŸŸ¡ ALTAserver/strategies/dualEntry5m/engine.tsEntry price Oracle-informed, TP dinÃ¡mico por OracleðŸŸ¡ ALTAserver/bot/order-manager.tsForzar maker orders (no cruzar spread), eliminar cascadaðŸŸ¢ MEDIAserver/bot/risk-manager.tsAgregar stop-loss check pre-tick, integrar progressive sizerðŸŸ¡ ALTADashboard ReactMostrar seÃ±ales Oracle, regime, stop-loss eventsðŸŸ¢ MEDIA

Orden de ImplementaciÃ³n Recomendado
Fase 1: ProtecciÃ³n (1-2 dÃ­as)
Prioridad: evitar repetir las pÃ©rdidas de la sesiÃ³n del 15 de febrero.

Stop-loss manager â€” El cambio de mayor impacto inmediato
Eliminar cascada de ventas â€” Una orden de salida, no 12
Progressive sizer â€” Empezar en $1 hasta demostrar rentabilidad

Fase 2: Edge (3-5 dÃ­as)
Prioridad: darle al bot una ventaja real.

Binance Oracle â€” Conectar WebSocket de Binance, capturar opening price
Integrar Oracle en MAKING â€” No operar sin seÃ±al
Market Regime Filter â€” No operar en condiciones desfavorables

Fase 3: OptimizaciÃ³n (1 semana)
Prioridad: maximizar el edge.

Maker orders obligatorios â€” 0% fees + rebates
Oracle-informed Dual Entry â€” Pricing asimÃ©trico por lado
TP dinÃ¡mico por Oracle â€” Profit targets basados en probabilidad real
Backtesting framework â€” Validar cambios contra datos histÃ³ricos


MÃ©tricas de Ã‰xito (Paper Trading)
Antes de pasar a live, el bot debe demostrar en paper trading:
MÃ©tricaMÃ­nimo RequeridoIdealWin Rate> 55%> 65%Profit Factor> 1.3> 2.0Max Drawdown< 15% del capital< 8%Sharpe Ratio (diario)> 0.5> 1.5Trades para validar100 mÃ­nimo500+DuraciÃ³n validaciÃ³n3 dÃ­as mÃ­nimo7 dÃ­asPÃ©rdida mÃ¡xima por trade< 15% del trade< 10%

Nota Final: La Realidad del Mercado
Los bots mÃ¡s exitosos en Polymarket BTC 5m/15m generan $500-$10,000/dÃ­a pero comparten estas caracterÃ­sticas:

Latencia sub-50ms al feed de precio de Binance
EjecuciÃ³n como maker (0 fees + rebates)
Win rate >85% gracias a ventaja informacional
Capital significativo ($4,000-$5,000 por trade)
VPS colocado cerca de los endpoints de Polymarket

Tu bot actual no tiene ninguna de estas. La mejora mÃ¡s realista para tu caso (targeting $200/mes) es:

Implementar el Binance Oracle como edge principal
Operar solo con seÃ±ales fuertes (quizÃ¡ 10-15 trades/dÃ­a en vez de 50+)
Proteger capital agresivamente con stop-loss del 10-15%
Empezar con $1-5 por trade hasta demostrar rentabilidad consistente
Correr el bot en un VPS de DigitalOcean NYC (cerca de los endpoints de Polymarket)

Con estas mejoras y disciplina, un objetivo de $5-10/dÃ­a ($150-300/mes) es alcanzable. Sin ellas, cada sesiÃ³n se parecerÃ¡ al -37.82% del 15 de febrero.ArtefactosDescargar todoPolymarket pnl report 2026 02 15Documento Â· DOCXÂ Polymaker strategy upgrade v2Documento Â· MDÂ 